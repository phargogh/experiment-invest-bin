cimport numpy
from libc.math cimport sqrt
import cython

#A constant to refer to the value we use to encode land
cdef float LAND = 1.0

cdef inline int int_round(float x): return <int>(x) if x-<int>x <= 0.5  else <int>(x+1)

class NotAtSea(Exception): pass
@cython.boundscheck(False)
def cast_ray(origin, direction, float d_max, 
             numpy.ndarray[numpy.float32_t, ndim=2] land_mask_array,
             numpy.ndarray[numpy.float32_t, ndim=2] bathymetry):
    """ March from the origin towards a direction until either land or a
    maximum distance is met.
    
        origin - a 2 element list indicating the i,j origin in 
            land_mask_array index coordinates
        direction - a 2 element numpy array indicating the  marching direction
            in terms of pixel distances
        d_max - a float to determin the maximum distance to traverse in terms of
            pixel units, should be > 1.0 units
        land_mask_array - a two dimensional numpy array with values either 
            0 or 1 indicating 1 as a land point and 0 as a sea point
        
        Returns the distance to the origin."""

    #Break into components for easy c conversion
    # Initialize the origin, step and path, break in components for c
    cdef double origini = origin[0]
    cdef double originj = origin[1]

    #These are used to calculate the average depth
    cdef double depth_accumulator = 0.0
    cdef int bathymetry_measurements = 0

    # Not on sea, no fetch
    if land_mask_array[<int>origini, <int>originj] == LAND:
        raise NotAtSea('Not at sea, no fetch')

    #Normalize direction so that the largest component is one pixel big
    cdef double unit_stepi = direction[0] / <double>(max(abs(direction)))
    cdef double unit_stepj = direction[1] / <double>(max(abs(direction)))

    #These are used to keep track of the running distance
    cdef double unit_step_length = sqrt(
        unit_stepi*unit_stepi + unit_stepj*unit_stepj)
    cdef double dist_traveled = 0.0

    #These will keep track of the current position
    cdef double posi = origini
    cdef double posj = originj

    #These will be used to round the position to nearest integer
    cdef int indexi
    cdef int indexj

    #Walk the ray
    while True:
        #Pick up the current depth value
        print ("bathy_c %s" % bathymetry[indexi, indexj])
        depth_accumulator += bathymetry[indexi, indexj]
        bathymetry_measurements += 1

        #calculate the position if we were to walk one more pixel over
        posi += unit_stepi
        posj += unit_stepj
        indexi = int_round(posi)
        indexj = int_round(posj)

        #see if we walked off the edge of the land_mask_array
        if indexi < 0 or indexi >= land_mask_array.shape[0] or \
                indexj < 0 or indexj >= land_mask_array.shape[1]:
            break

        #see if we hit land
        if land_mask_array[indexi, indexj] == LAND:
            break

        #If we got here, it's safe to take a step, so accumulate 
        #the distance traveled
        dist_traveled += unit_step_length

        #See if we've traveled beyond d_max and stop if so
        if dist_traveled > d_max:
            dist_traveled -= unit_step_length
            break

    #Report the actual distance we were able to walk
    return (dist_traveled, depth_accumulator/bathymetry_measurements)
